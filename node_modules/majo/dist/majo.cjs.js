'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fsExtra = require('fs-extra');
var globby = _interopDefault(require('globby'));
var path = _interopDefault(require('path'));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class Wares {
    constructor() {
        this.middlewares = [];
    }
    use(middleware) {
        this.middlewares = this.middlewares.concat(middleware);
        return this;
    }
    run(context) {
        return this.middlewares.reduce((current, next) => {
            return current.then(() => Promise.resolve(next(context)));
        }, Promise.resolve());
    }
}

class Majo {
    constructor() {
        this.middlewares = [];
        this.meta = {};
    }
    /**
     * Define how to find files
     * @param source Glob patterns
     * @param options
     * @param options.baseDir The base dir to look for files
     * @param options.dotFiles Include dot files
     */
    source(source, { baseDir = '.', dotFiles = true } = {}) {
        this.baseDir = path.resolve(baseDir);
        this.sourcePatterns = source;
        this.dotFiles = dotFiles;
        return this;
    }
    /**
     * Add middleware
     * @param middleware Middleware
     */
    use(middleware) {
        this.middlewares.push(middleware);
        return this;
    }
    /**
     * Process all middlewares
     */
    process() {
        return __awaiter(this, void 0, void 0, function* () {
            const statCache = {};
            const paths = yield globby(this.sourcePatterns, {
                cwd: this.baseDir,
                dot: this.dotFiles,
                nodir: true,
                statCache
            });
            this.files = {};
            yield Promise.all(paths.map((relative) => __awaiter(this, void 0, void 0, function* () {
                const absolutePath = path.resolve(this.baseDir, relative);
                return fsExtra.readFile(absolutePath).then(contents => {
                    const stats = statCache[path.isAbsolute(this.baseDir) ? absolutePath : relative];
                    const file = { contents, stats, path: absolutePath };
                    this.files[relative] = file;
                });
            })));
            yield new Wares().use(this.middlewares).run(this);
            return this.files;
        });
    }
    /**
     * Add a filter to include/exclude files
     */
    filter(fn) {
        return this.use(context => {
            Object.keys(context.files).forEach(relative => {
                if (!fn(relative, context.files[relative])) {
                    // tslint:disable-next-line
                    delete context.files[relative];
                }
            });
        });
    }
    /**
     * Transform files
     * @param relative Relative path of a file
     * @param fn The function to transform file
     */
    transform(relative, fn) {
        return __awaiter(this, void 0, void 0, function* () {
            const contents = this.files[relative].contents.toString();
            const result = yield fn(contents);
            this.files[relative].contents = Buffer.from(result);
            return this;
        });
    }
    /**
     * Write files
     * @param dest The output directory
     * @param options
     * @param options.baseDir The base directory to resolve `dest`
     * @param options.clean Whether to clean output directory before writing
     */
    dest(dest, { baseDir = '.', clean = false } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const destPath = path.resolve(baseDir, dest);
            const files = yield this.process();
            if (clean) {
                yield fsExtra.remove(destPath);
            }
            yield Promise.all(Object.keys(files).map((filename) => __awaiter(this, void 0, void 0, function* () {
                const { contents } = files[filename];
                const target = path.join(destPath, filename);
                return fsExtra.ensureDir(path.dirname(target)).then(() => __awaiter(this, void 0, void 0, function* () { return fsExtra.writeFile(target, contents); }));
            })));
        });
    }
    /**
     * Get contents of specific file
     * @param relative The relative path of a file
     */
    fileContents(relative) {
        return this.file(relative).contents.toString();
    }
    /**
     * Write contents to a file
     * @param relative The relative path of a file
     * @param str File contents as a string
     */
    writeContents(relative, str) {
        this.files[relative].contents = Buffer.from(str);
        return this;
    }
    /**
     * Get the stats of a file
     * @param relative The relative path of a file
     */
    fileStats(relative) {
        return this.file(relative).stats;
    }
    /**
     * Get a file
     * @param relative The relative path of a file
     */
    file(relative) {
        return this.files[relative];
    }
    /**
     * Delete a file
     * @param relative The relative path of a file
     */
    deleteFile(relative) {
        // tslint:disable-next-line
        delete this.files[relative];
        return this;
    }
    /**
     * Create a file
     * @param relative The relative path of a file
     * @param file File
     */
    createFile(relative, file) {
        this.files[relative] = file;
        return this;
    }
    /**
     * Get the list of file names
     */
    get fileList() {
        return Object.keys(this.files).sort();
    }
}
const majo = () => new Majo();
// For CommonJS default export support
module.exports = majo;
// So that const majo = require('majo').default works too
module.exports.default = majo;

exports.Majo = Majo;
exports.default = majo;
