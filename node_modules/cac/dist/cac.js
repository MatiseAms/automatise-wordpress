'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var minimost = _interopDefault(require('minimost'));
var path = _interopDefault(require('path'));
var EventEmitter = _interopDefault(require('events'));
var chalk = _interopDefault(require('chalk'));
var readPkg = _interopDefault(require('read-pkg-up'));
var table = _interopDefault(require('text-table'));
var stringWidth = _interopDefault(require('string-width'));
var redent = _interopDefault(require('redent'));

class CacError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CacError';
  }
}

function parseType(type) {
  if (typeof type === 'string' || type instanceof String) {
    return type;
  }

  if (type === Boolean) {
    return 'boolean';
  }
}

function orderNames(names) {
  return names.sort((a, b) => {
    return a.length > b.length;
  });
}

function textTable(data) {
  return table(data, {
    stringLength: stringWidth
  });
}

function prefixOption(option) {
  return option.length === 1 ? `-${option}` : `--${option}`;
}

function isExplictCommand(name) {
  return name && !name.startsWith('-');
}

function invariant(exp, message) {
  if (!exp) {
    throw new CacError(message);
  }
}

class Options {
  constructor() {
    this.options = [];
  }

  add(name, opt) {
    opt = opt || {};
    if (typeof opt === 'string') {
      opt = { desc: opt };
    }
    const option = Object.assign({}, opt, {
      name,
      alias: opt.alias || [],
      desc: opt.desc,
      default: opt.default,
      type: parseType(opt.type)
    });
    option.names = orderNames([option.name].concat(option.alias));
    this.options.push(option);
    return this;
  }

  getDefaultsMapping() {
    return this.options.filter(option => {
      return typeof option.default !== 'undefined';
    }).reduce((res, next) => {
      res[next.name] = next.default;
      return res;
    }, {});
  }

  getOptionsByType(type) {
    return this.options.filter(option => type === option.type);
  }

  getOptionNamesByType(type) {
    return this.getOptionsByType(type).map(option => option.name);
  }

  getAliasMap() {
    return this.options.reduce((res, next) => {
      res[next.name] = next.alias;
      return res;
    }, {});
  }

  isEmpty() {
    return this.options.length === 0;
  }

  toString() {
    return textTable(this.options.map(option => {
      const extra = [];
      if (typeof option.default !== 'undefined') {
        extra.push(`Default: ${JSON.stringify(option.default)}`);
      }
      if (typeof option.type === 'string') {
        extra.push(`Type: ${option.type}`);
      }
      return [option.names.map(v => chalk.yellow(prefixOption(v))).join(', '), chalk.dim(option.desc), extra.map(v => chalk.dim(`[${v}]`)).join(' ')];
    }));
  }
}

// @ts-check
class Command {
  constructor(name, option, handler) {
    option = option || {};
    if (typeof option === 'string') {
      option = { desc: option };
    }

    invariant(typeof name === 'string', 'Expect command name to be a string.');
    invariant(option.desc, 'Expect command to have a description.');

    const command = Object.assign({}, option, {
      name,
      alias: option.alias || [],
      desc: option.desc
    });

    command.names = orderNames([command.name].concat(command.alias));

    this.command = command;
    this.options = new Options();
    this.handler = handler;
  }

  option(...args) {
    this.options.add(...args);
    return this;
  }
}

class Help {
  constructor(root, command, opts = {}) {
    this.root = root;
    this.command = command;
    this.opts = opts;
  }

  getHelp() {
    let help = '\n';

    help += chalk.cyan(this.root.bin);

    if (this.root.pkg.version) {
      help += ` ${this.root.pkg.version}`;
    }

    help += '\n\n';

    if (this.root.pkg.description) {
      help += `${chalk.dim.italic(this.root.pkg.description)}\n\n`;
    }

    const commandText = this.command ? chalk.magenta(this.opts.displayCommands ? '<command> ' : `${this.command.command.name} `) : '';
    help += `${chalk.bold('USAGE')}\n\n`;
    help += redent(`${chalk.dim.italic(this.root.bin)} ${commandText}${chalk.yellow('[options]')}`, 2);
    help += '\n\n';

    if (this.opts.displayCommands && !this.root.isCommandsEmpty()) {
      help += formatSection({
        title: 'COMMANDS',
        body: this.root.commandsToString()
      });
    }

    if (this.command && !this.command.options.isEmpty()) {
      help += formatSection({
        title: 'COMMAND OPTIONS',
        body: this.command.options.toString()
      });
    }

    if (!this.root.options.isEmpty()) {
      help += formatSection({
        title: 'GLOBAL OPTIONS',
        body: this.root.options.toString()
      });
    }

    for (const h of this.root.extraHelps) {
      help += formatSection(h);
    }

    return redent(help, 2);
  }

  output() {
    process.stdout.write(this.getHelp());
    return this;
  }
}

function formatSection(sec) {
  if (typeof sec === 'string') {
    return sec;
  }

  const { title, body } = sec;
  return `${title ? `${chalk.bold(title)}\n\n` : ''}${redent(body.trim(), 2)}\n\n`;
}

var examplesPlugin = (() => cli => {
  cli.on('parsed', command => {
    if (command && command.command.examples) {
      cli.extraHelp({
        title: 'EXAMPLES',
        body: command.command.examples.join('\n')
      });
    }
  });
});

var optionChoicesPlugin = (() => cli => {
  cli.on('parsed', (command, input, flags) => {
    if (!command) { return; }

    const failedOptions = command.options.options.filter(option => {
      const shouldCheck = option.choices && typeof flags[option.name] !== 'undefined';
      const isOneOfChices = option.choices && option.choices.filter(choice => {
        return choice === flags[option.name];
      }).length > 0;
      return shouldCheck && !isOneOfChices;
    });

    if (failedOptions.length > 0) {
      for (const option of failedOptions) {
        console.log(`The value of flag "${option.name}" should be one of: ${option.choices.map(choice => `"${choice}"`)}`);
      }
      process.exit(1); // eslint-disable-line unicorn/no-process-exit
    }
  });
});

var requiredOptionPlugin = (() => cli => {
  cli.on('parsed', (command, input, flags) => {
    if (!command) { return; }

    const missingRequiredOptions = command.options.options.filter(option => {
      const isRequired = option.required;
      const isMissing = typeof flags[option.name] === 'undefined';
      return isMissing && isRequired;
    });
    if (missingRequiredOptions.length > 0) {
      console.log(`Missing options: ${missingRequiredOptions.map(option => option.name).join(', ')}`);
      process.exit(1); // eslint-disable-line unicorn/no-process-exit
    }
  });
});

// Prevent caching of this module so module.parent is always accurate
delete require.cache[__filename];
const parentDir = path.dirname(module.parent.filename);

class Cac extends EventEmitter {
  constructor({ bin, pkg, defaultOpts = true } = {}) {
    super();
    this.bin = bin || path.basename(process.argv[1]);
    this.commands = [];
    this.options = new Options();
    this.extraHelps = [];
    this.helpOpt = defaultOpts !== false && defaultOpts.help !== false;
    this.versionOpt = defaultOpts !== false && defaultOpts.version !== false;

    this.pkg = Object.assign({}, pkg || readPkg.sync({ cwd: parentDir, normalize: false }).pkg);

    if (this.versionOpt) {
      this.option('version', {
        alias: 'v',
        type: 'boolean',
        desc: 'Display version'
      });
    }
    if (this.helpOpt) {
      this.option('help', {
        alias: 'h',
        type: 'boolean',
        desc: `Display help (You're already here)`
      });
    }

    this.use(examplesPlugin());
    this.use(optionChoicesPlugin());
    this.use(requiredOptionPlugin());
  }

  use(plugin) {
    if (Array.isArray(plugin)) {
      plugin.forEach(p => this.use(p));
    } else if (typeof plugin === 'function') {
      plugin(this);
    } else {
      throw new TypeError('plugin has to be a function or an array of it.');
    }
    return this;
  }

  option(...args) {
    this.options.add(...args);
    return this;
  }

  command(...args) {
    const command = new Command(...args);
    this.commands.push(command);
    return command;
  }

  commandsToString() {
    return textTable(this.commands.map(({ command }) => {
      return [command.names.map(v => chalk.magenta(v)).join(', '), chalk.dim(command.desc)];
    }));
  }

  isCommandsEmpty() {
    return this.commands.length === 0;
  }

  /**
   * Find command by command name, alias or addtionalMatch
   */
  findCommand(name) {
    for (const command of this.commands) {
      const { names, match } = command.command;
      if (names.includes(name)) {
        return { command, sliceFirstArg: name && name !== '*' };
      }
      if (match && match(name)) {
        return { command, sliceFirstArg: false };
      }
    }
    return null;
  }

  getCommand(name) {
    return this.findCommand(name) || this.findCommand('*') || {};
  }

  get argv() {
    return this.parse(null, { run: false });
  }

  showHelp() {
    if (!this.started) {
      throw new Error('[cac] You have to call .parse() before running .showHelp()');
    }

    // Do not display `<command>` in help if it's a sub command
    const displayCommands = !( // This matches a sub command
    this.matchedCommand && isExplictCommand(this.firstArg));
    const help = new Help(this, this.matchedCommand, {
      displayCommands
    });

    help.output();
    return this;
  }

  showVersion() {
    console.log(this.pkg.version);
  }

  extraHelp(help) {
    this.extraHelps.push(help);
    return this;
  }

  parse(argv, { run = true, showHelp } = {}) {
    this.started = true;
    argv = argv || process.argv.slice(2);
    this.firstArg = argv[0] || '';
    // Ensure that first arg is not a flag
    this.firstArg = this.firstArg.startsWith('-') ? null : this.firstArg;
    const { command, sliceFirstArg } = this.getCommand(this.firstArg);
    this.matchedCommand = command;

    let { input, flags } = minimost(argv, {
      boolean: [...this.options.getOptionNamesByType('boolean'), ...(command ? command.options.getOptionNamesByType('boolean') : [])],
      string: [...this.options.getOptionNamesByType('string'), ...(command ? command.options.getOptionNamesByType('string') : [])],
      default: Object.assign({}, this.options.getDefaultsMapping(), command ? command.options.getDefaultsMapping() : []),
      alias: Object.assign({}, this.options.getAliasMap(), command ? command.options.getAliasMap() : {})
    });

    input = sliceFirstArg ? input.slice(1) : input;

    this.emit('parsed', command, input, flags);

    if (!run) {
      return { input, flags };
    }

    const shouldShowHelp = showHelp || ((command, input, flags) => this.helpOpt && flags.help);

    if (shouldShowHelp(command, input, flags)) {
      this.showHelp();
    } else if (this.versionOpt && flags.version) {
      this.showVersion();
    } else if (command && command.handler) {
      try {
        let res = command.handler(input, flags);
        if (res && res.catch) {
          res = res.catch(err => this.handleError(err));
        }
        this.emit('executed', command, input, flags);
        return res;
      } catch (err) {
        this.handleError(err);
      }
    }
  }

  handleError(err) {
    if (EventEmitter.listenerCount(this, 'error') === 0) {
      console.error(err.stack);
      process.exitCode = process.exitCode || 1;
    } else {
      this.emit('error', err);
    }
  }
}

function cac(opts) {
  return new Cac(opts);
}

cac.parse = (...args) => minimost(...args);

module.exports = cac;
